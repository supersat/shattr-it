<!DOCTYPE html>
<html>
<!--
Licensed under The MIT License (MIT)

Copyright (c) 2014 Karl Koscher

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<head>
    <title>Shattr. Distributing Trust.</title>
    <meta name="Keywords" content="Shamir,secret,sharing,Bitlocker,Javascript" />
    <meta name="Description" content="Securely split your encryption keys among trusted third parties." />

    <style type="text/css">
        body 
        {
            font-family: "Open Sans", "Proxima Nova Regular", "Helvetica Neue", "Calibri", "Droid Sans", "Helvetica", "Arial", "sans-serif";
            margin: 0px 0px;
            background-color: rgb(96, 96, 96);
        }
        
        p
        {
            margin: 0em 0em 1em 0em;
        }
        
        #menu 
        {
            background: -webkit-linear-gradient(top, #fefefe, #ddd);
            background: -moz-linear-gradient(top, #fefefe, #ddd);
            padding: 0px 15px;
            font-size: 20pt;
            font-weight: 600;
            text-align: center;
        }
        
        a.menubutton
        {
            margin: 15px 15px;
        }
        
        h1
        {
            text-align: center;
            font-size: 72px;
            color: White;
        }
        
        #column 
        {
            width: 800px;
            margin: auto;
            background-color: #f0f0f0;
        }
        
        #content
        {
            padding: 15px 15px;
        }
        
        #shardoutput
        {
            font-family: monospace;
            font-weight: bold;
        }
        
        .app
        {
            display: none;
            text-align: center;
            font-size: 24pt;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0,0,0,.4), 0 0 30px rgba(0,0,0,.075);
        }
        
        .keyinput
        {
            margin: 0.25em 0em;
        }
        
        .hidden
        {
            display: none;
        }
        
        input
        {
            font-size: 16pt;
        }
        
        select
        {
            font-size: 24pt;
        }
        
        .hexkey
        {
            width: 700px;
            font-family: monospace;
            font-weight: bold;
        }
        
        .blkey 
        {
            width: 3.5em;
            font-family: monospace;
            font-weight: bold;
        }
        
        input.button
        {
            color: #ffffff;
            text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
            background-color: #006dcc;
            background-image: -moz-linear-gradient(top, #0088cc, #0044cc);
            background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0088cc), to(#0044cc));
            background-image: -webkit-linear-gradient(top, #0088cc, #0044cc);
            background-image: -o-linear-gradient(top, #0088cc, #0044cc);
            background-image: linear-gradient(to bottom, #0088cc, #0044cc);
            background-repeat: repeat-x;
            border: 1px solid;
            border-color: #0044cc #0044cc #002a80;
            border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc', endColorstr='#ff0044cc', GradientType=0);
            filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);
            padding: 4px 12px;
            margin: 0;
            font-size: 14px;
            line-height: 20px;
            cursor: pointer;
            vertical-align: middle;
            -webkit-border-radius: 4px;
            -moz-border-radius: 4px;
            border-radius: 4px;
            -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
            -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
        }
    </style>
    <script type="text/javascript">

    ///////////////////////////////////// Galois Field Functions ///////////////////////////////////////
    // We use the Rijndael (AES) finite field, GF(2^8) with reducing polynomial x^8 + x^4 + x^3 + x + 1.
    // These log and anti-log tables are derived from http://www.samiam.org/logtables.txt with a
    // a generator of 3.

    gf_log_tbl = [
        0x00, 0xff, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03,
        0x64, 0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1,
        0x7d, 0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78,
        0x65, 0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e,
        0x96, 0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38,
        0x66, 0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10,
        0x7e, 0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba,
        0x2b, 0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57,
        0xaf, 0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8,
        0x2c, 0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0,
        0x7f, 0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7,
        0xcc, 0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d,
        0x97, 0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1,
        0x53, 0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab,
        0x44, 0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5,
        0x67, 0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07 ];

    gf_anti_log_tbl = [
        0x01, 0x03, 0x05, 0x0f, 0x11, 0x33, 0x55, 0xff, 0x1a, 0x2e, 0x72, 0x96, 0xa1, 0xf8, 0x13, 0x35,
        0x5f, 0xe1, 0x38, 0x48, 0xd8, 0x73, 0x95, 0xa4, 0xf7, 0x02, 0x06, 0x0a, 0x1e, 0x22, 0x66, 0xaa,
        0xe5, 0x34, 0x5c, 0xe4, 0x37, 0x59, 0xeb, 0x26, 0x6a, 0xbe, 0xd9, 0x70, 0x90, 0xab, 0xe6, 0x31,
        0x53, 0xf5, 0x04, 0x0c, 0x14, 0x3c, 0x44, 0xcc, 0x4f, 0xd1, 0x68, 0xb8, 0xd3, 0x6e, 0xb2, 0xcd,
        0x4c, 0xd4, 0x67, 0xa9, 0xe0, 0x3b, 0x4d, 0xd7, 0x62, 0xa6, 0xf1, 0x08, 0x18, 0x28, 0x78, 0x88,
        0x83, 0x9e, 0xb9, 0xd0, 0x6b, 0xbd, 0xdc, 0x7f, 0x81, 0x98, 0xb3, 0xce, 0x49, 0xdb, 0x76, 0x9a,
        0xb5, 0xc4, 0x57, 0xf9, 0x10, 0x30, 0x50, 0xf0, 0x0b, 0x1d, 0x27, 0x69, 0xbb, 0xd6, 0x61, 0xa3,
        0xfe, 0x19, 0x2b, 0x7d, 0x87, 0x92, 0xad, 0xec, 0x2f, 0x71, 0x93, 0xae, 0xe9, 0x20, 0x60, 0xa0,
        0xfb, 0x16, 0x3a, 0x4e, 0xd2, 0x6d, 0xb7, 0xc2, 0x5d, 0xe7, 0x32, 0x56, 0xfa, 0x15, 0x3f, 0x41,
        0xc3, 0x5e, 0xe2, 0x3d, 0x47, 0xc9, 0x40, 0xc0, 0x5b, 0xed, 0x2c, 0x74, 0x9c, 0xbf, 0xda, 0x75,
        0x9f, 0xba, 0xd5, 0x64, 0xac, 0xef, 0x2a, 0x7e, 0x82, 0x9d, 0xbc, 0xdf, 0x7a, 0x8e, 0x89, 0x80,
        0x9b, 0xb6, 0xc1, 0x58, 0xe8, 0x23, 0x65, 0xaf, 0xea, 0x25, 0x6f, 0xb1, 0xc8, 0x43, 0xc5, 0x54,
        0xfc, 0x1f, 0x21, 0x63, 0xa5, 0xf4, 0x07, 0x09, 0x1b, 0x2d, 0x77, 0x99, 0xb0, 0xcb, 0x46, 0xca,
        0x45, 0xcf, 0x4a, 0xde, 0x79, 0x8b, 0x86, 0x91, 0xa8, 0xe3, 0x3e, 0x42, 0xc6, 0x51, 0xf3, 0x0e,
        0x12, 0x36, 0x5a, 0xee, 0x29, 0x7b, 0x8d, 0x8c, 0x8f, 0x8a, 0x85, 0x94, 0xa7, 0xf2, 0x0d, 0x17,
        0x39, 0x4b, 0xdd, 0x7c, 0x84, 0x97, 0xa2, 0xfd, 0x1c, 0x24, 0x6c, 0xb4, 0xc7, 0x52, 0xf6, 0x01 ];

    function gf_add(a, b) {
        return a ^ b;
    }

    function gf_sub(a, b) {
        return a ^ b;
    }

    function gf_mul(a, b) {
        if (a == 0 || b == 0)
            return 0;

        var sum = gf_log_tbl[a] + gf_log_tbl[b];
        if (sum > 0xff)
            sum -= 0xff;
        return gf_anti_log_tbl[sum];
    }

    function gf_div(a, b) {
        if (b == 0)
            throw "Cannot divide by zero";

        var diff = gf_log_tbl[a] - gf_log_tbl[b];
        if (diff < 0)
            diff += 0xff;
        return gf_anti_log_tbl[diff];
    }

    function gf_pow(a, b) {
        res = 1;

        while (b-- > 0) {
            res = gf_mul(res, a);
        }

        return res;
    }
    
    ////////////////////////////// Bitlocker Key Processing Functions //////////////////////////////
    // Bitlocker recovery keys are 128 bits in length, broken up into groups of
    // 16 bits. Each group is multiplied by 11 to enable a basic level of error
    // checking. See http://blogs.msdn.com/b/si_team/archive/2006/08/10/694692.aspx

    function validateBitlockerGroup(num) {
        if (num > 720885)
            return false;
        return (num % 11) == 0;
    }

    function parseBitlockerKey(str) {
        if (str.length != 48)
            throw "Invalid key length";

        var key = new Uint8Array(16);
        for (var i = 0; i < 8; i++) {
            n = str.substr(i * 6, 6) / 11;
            key[i << 1] = n & 0xff;
            key[(i << 1) + 1] = n >> 8;
        }

        return key;
    }

    function byteArrayToBitlockerKey(arr, id) {
        if (arr.length != 16)
            throw "Invalid key length";

        var str = '';
        var i = 0;
        while (i < arr.length) {
            var n = (arr[i] | (arr[i + 1] << 8)) * 11;
            // We extend the Bitlocker error detection scheme by encoding the
            // key id as the remainder of the group modulo 11. The first four
            // groups encode the 10s digit, while the second four encode the 1s
            // digit. All remainders in each set of four number groups must
            // match. If one doesn't, then it wasn't entered correctly.
            if (i < 8) {
                n = n + Math.floor(id / 10) + '';
            } else {
                n = n + (id % 10) + '';
            }
            while (n.length < 6) {
                n = '0' + n;
            }
            str += n;
            i += 2;
            if (i != arr.length) {
                str += '-';
            }
        }
        return str;
    }

    function getBitlockerShardId(str) {
        var mod = new Array();
        for (var i = 0; i < 8; i++) {
            mod[i] = str.substr(i * 6, 6) % 11;
        }

        for (var i = 0; i < 3; i++) {
            if ((mod[i] != mod[i + 1]) || (mod[i + 4] != mod[i + 5])) {
                throw "Bitlocker shard is not valid";
            }
        }

        return mod[0] * 10 + mod[4];
    }

    ///////////////////////////////// Hex Key Processing Functions /////////////////////////////////
    function hexCharToValue(c) {
        if (c >= 0x30 && c <= 0x39) {
            c -= 0x30;
        } else if (c >= 0x41 && c <= 0x46) {
            c -= 0x37;
        } else if (c >= 0x61 && c <= 0x66) {
            c -= 0x57;
        } else {
            throw "Invalid hex character encountered";
        }

        return c;
    }

    function parseHexString(str) {
        if (str.length & 1)
            throw "Length of hex string must be a multiple of 2";

        var byteArray = new Uint8Array(str.length >> 1);

        for (var i = 0; i < byteArray.length; i++) {
            byteArray[i] = (hexCharToValue(str.charCodeAt(i << 1)) << 4) | 
                           (hexCharToValue(str.charCodeAt((i << 1) + 1)));
        }

        return byteArray;
    }

    function decimalToHexChar(c) {
        if (c > 9) {
            return String.fromCharCode(c + 0x57);
        } else {
            return String.fromCharCode(c + 0x30);
        }
    }

    function byteArrayToHexString(arr) {
        var str = '';
        for (var i = 0; i < arr.length; i++) {
            str += decimalToHexChar(arr[i] >> 4) + decimalToHexChar(arr[i] & 0xf);
        }
        return str;
    }

    //////////////////////// Shamir Secret Sharing Implementation Functions ////////////////////////
    function computeShards(key, threshold, numShards) {
        var coeffs = new Uint8Array(threshold - 1);
        var shards = Array();
        for (var i = 0; i < numShards; i++) {
            shards[i] = new Uint8Array(key.length);
        }

        for (var i = 0; i < key.length; i++) {
            window.crypto.getRandomValues(coeffs);

            for (var x = 0; x < numShards; x++) {
                var y = key[i];
                for (var c = 0; c < coeffs.length; c++) {
                    y = gf_add(y, gf_mul(coeffs[c], gf_pow(x + 1, c + 1)));
                }
                shards[x][i] = y;
            }
        }

        return shards;
    }

    function computeCombine(shares_x, shards) {
        if (shards.length < 2) 
            throw "You must supply at least two shards";
        for (var i = 0; i < shards.length - 1; i++) {
            if (shards[i].length != shards[i + 1].length)
                throw "Shards must all be the same length";
        }

        var len = shards[0].length;
        var output = new Uint8Array(len);

        for (var b = 0; b < len; b++) {
            var sum = 0;
            for (var i = 0; i < shares_x.length; i++) {
                var num = 1;
                var denom = 1;
                for (var j = 0; j < shares_x.length; j++) {
                    if (i != j) {
                        num = gf_mul(num, gf_sub(0, shares_x[j]));
                        denom = gf_mul(denom, gf_sub(shares_x[i], shares_x[j]));
                    }
                }
                sum = gf_add(sum, gf_mul(shards[i][b], gf_div(num, denom)));
            }
            output[b] = sum;
        }

        return output;
    }

    /////////////////////////////////// User Interface Functions ///////////////////////////////////
    function hideChildrenOf(id) {
        var children = document.getElementById(id).childNodes;
        for (var i = 0; i < children.length; i++) {
            if (children[i].nodeName == 'DIV')
                children[i].style.display = 'none';
        }
    }

    function showPage(page) {
        hideChildrenOf("content");
        document.getElementById(page).style.display = 'block';
    }

    function shardTypeSelected() {
        var type = document.getElementById("shardtype").value;
        hideChildrenOf("shardinputs");
        if (type == 'hex') {
            document.getElementById("shardhexinput").style.display = 'block';
            document.getElementById("key").value = '';
        } else if (type == 'bitlocker') {
            document.getElementById("shardbitlockerinput").style.display = 'block';
            document.getElementById("blkey1").value = '';
            document.getElementById("blkey2").value = '';
            document.getElementById("blkey3").value = '';
            document.getElementById("blkey4").value = '';
            document.getElementById("blkey5").value = '';
            document.getElementById("blkey6").value = '';
            document.getElementById("blkey7").value = '';
            document.getElementById("blkey8").value = '';
        } else if (type == 'file') {
            document.getElementById("shardfileinput").style.display = 'block';
            document.getElementById("shardfileinput").innerHTML = 'Drag your file here!';
            window.fileData = null;
        }
        document.getElementById("shardoptions").style.display = 'block';
        document.getElementById("shardoutput").style.display = 'none';
    }

    function dragenter(e) {
        e.stopPropagation();
        e.preventDefault();
    }

    function dragover(e) {
        e.stopPropagation();
        e.preventDefault();
    }

    function shardFileDrop(e) {
        e.stopPropagation();
        e.preventDefault();
        window.fileData = null;
        var file = e.dataTransfer.files[0];
        var fileReader = new FileReader();
        window.shardFile = file;
        document.getElementById("shardfileinput").innerHTML = "Loading " + file.name;
        fileReader.readAsArrayBuffer(file);
        fileReader.onerror = function () {
            document.getElementById("shardfileinput").innerHTML = "Error loading " + file.name;
        };
        fileReader.onloadend = function () {
            document.getElementById("shardfileinput").innerHTML = "Loaded " + file.name;
            window.fileData = fileReader.result;
        };
    }

    function combineFileDrop(e) {
        e.stopPropagation();
        e.preventDefault();
        window.fileData = null;
        var file = e.dataTransfer.files[0];
        var fileReader = new FileReader();
        window.combineFile = file;
        document.getElementById("combinefileinput").innerHTML = "Loading " + file.name;
        fileReader.readAsArrayBuffer(file);
        fileReader.onerror = function () {
            document.getElementById("combinefileinput").innerHTML = "Error loading " + file.name;
        };
        fileReader.onloadend = function () {
            document.getElementById("combinefileinput").innerHTML = "Loaded " + file.name;
            window.fileData = fileReader.result;
        };
    }

    function shardFileEncryptDone(data, iv) {
        var url = URL.createObjectURL(new Blob([iv, data], { type: "application/octet-stream" }));
        var dlLink = document.createElement("a");
        dlLink.href = url;
        dlLink.download = window.shardFile.name + ".aes128gcm.shattr.enc";
        dlLink.click();
        URL.revokeObjectURL(url);
    }

    function shardGeneratedKey(key)
    {
        var outputDiv = document.getElementById("shardoutput");
        var numShards = document.getElementById("shards").value;
        var threshold = document.getElementById("threshold").value;

        var shards = computeShards(new Uint8Array(key), threshold, numShards);

        for (var i = 0; i < shards.length; i++) {
            outputDiv.innerHTML += byteArrayToBitlockerKey(shards[i], i + 1) + "<br />";
        }
    }

    function shardFileKeygenDone(key) {
        var iv = window.crypto.getRandomValues(new Uint8Array(16));
        var encOp = window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key,
            new Uint8Array(window.fileData));
        encOp.then(function (data) { shardFileEncryptDone(data, iv); });
        
        var exportOp = window.crypto.subtle.exportKey("raw", key);
        exportOp.then(shardGeneratedKey);
    }

    function shardRSAKeygenDone(key) {
        var exportOp = window.crypto.subtle.exportKey("pkcs8", key.privateKey);
        exportOp.then(shardGeneratedKey);
    }

    function shardECDSAKeygenDone(key) {
        var exportOp = window.crypto.subtle.exportKey("pkcs8", key.privateKey);
        exportOp.then(shardGeneratedKey);
    }

    function shard() {
        var outputDiv = document.getElementById("shardoutput");
        outputDiv.style.display = 'block';
        outputDiv.innerHTML = '';

        var key;
        var type = document.getElementById("shardtype").value;
        if (type == 'hex') {
            key = parseHexString(document.getElementById("key").value);
        } else if (type == 'bitlocker') {
            key = document.getElementById("blkey1").value;
            key += document.getElementById("blkey2").value;
            key += document.getElementById("blkey3").value;
            key += document.getElementById("blkey4").value;
            key += document.getElementById("blkey5").value;
            key += document.getElementById("blkey6").value;
            key += document.getElementById("blkey7").value;
            key += document.getElementById("blkey8").value;
            key = parseBitlockerKey(key);
        } else if (type == 'file') {
            var keyGenOp = window.crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 128 }, true,
                ["encrypt", "decrypt"]);
            keyGenOp.then(shardFileKeygenDone);
            return;
        } else if (type == 'rsa') {
            var keyGenOp = window.crypto.subtle.generateKey(
                { name: 'RSASSA-PKCS1-v1_5', modulusLength: 2048,
                    hash: { name: 'SHA-256' },
                    publicExponent: parseHexString('010001')
                }, true, ["sign", "verify"]);
            keyGenOp.then(shardRSAKeygenDone);
            return;
        } else if (type == 'ecdsa') {
            var keyGenOp = window.crypto.subtle.generateKey(
                { name: 'ECDSA', namedCurve: 'P-256' }, 
                true, ["sign", "verify"]);
            keyGenOp.then(shardECDSAKeygenDone);
            return;
        }
        var numShards = document.getElementById("shards").value;
        var threshold = document.getElementById("threshold").value;
        var shards = computeShards(key, threshold, numShards);

        if (type == 'hex') {
            for (var i = 0; i < shards.length; i++) {
                var id = i + 1;
                if (id < 10) {
                    id = '0' + id;
                }
                outputDiv.innerHTML += id + byteArrayToHexString(shards[i]) + "<br />";
            }
        } else if (type == 'bitlocker') {
            for (var i = 0; i < shards.length; i++) {
                outputDiv.innerHTML += byteArrayToBitlockerKey(shards[i], i + 1) + "<br />";
            }
        }
    }

    function combineTypeSelected() {
        var type = document.getElementById("combinetype").value;
        var inputDiv = document.getElementById("combineinput");
        inputDiv.innerHTML = '';
        if (type == 'hex') {
            addHexInput(0);
        } else if (type == 'bitlocker') {
            addBitlockerInput(0);
        } else if (type == 'file') {
            addBitlockerInput(0);
            document.getElementById("combinefileinput").style.display = "block";
        }
    }

    function addHexInput(id) {
        var inputDiv = document.getElementById("combineinput");
        var newInput = document.createElement("input");
        newInput.id = "hexcombine_" + id;
        newInput.type = "text";
        newInput.className = "hexkey";
        newInput.setAttribute("maxlength", 128);
        newInput.placeholder = "Hex shard";
        newInput.addEventListener("input", function () { addNextHexCombineInput(id + 1); });
        inputDiv.appendChild(newInput);
        inputDiv.appendChild(document.createElement("br"));
    }

    function addNextHexCombineInput(id) {
        var nextInput = document.getElementById("hexcombine_" + id);
        if (nextInput == null) {
            addHexInput(id);
        }
    }

    function addBitlockerInput(id) {
        var inputDiv = document.getElementById("combineinput");
        for (var i = 0; i < 8; i++) {
            var newInput = document.createElement("input");
            newInput.id = "blc_" + id + "_" + i;
            newInput.type = "text";
            newInput.className = "blkey";
            newInput.setAttribute("maxlength", 6);
            newInput.placeholder = "000000";
            newInput.addEventListener("input", (function (x) { return function () { validateBLKCombine(id, x); }; })(i));
            inputDiv.appendChild(newInput);
            if (i != 7)
                inputDiv.appendChild(document.createTextNode("-"));
        }
        inputDiv.appendChild(document.createElement("br"));
    }

    function validateBLKCombine(id, i) {
        var len = document.getElementById("blc_" + id + "_7").value.length;
        if (i == 7 && len == 6) {
            var nextInput = document.getElementById("blc_" + (id + 1) + "_0");
            if (nextInput == null) {
                addBitlockerInput(id + 1);
            }
        }
    }

    function combine() {
        var type = document.getElementById("combinetype").value;
        var shard_ids = new Array();
        var shards = new Array();
        var input;
        if (type == 'hex') {
            for (var i = 0; (input = document.getElementById("hexcombine_" + i)) != null; i++) {
                if (input.value.length == 0)
                    continue;
                shard_ids[i] = parseInt("0x" + input.value.substr(0, 2));
                shards[i] = parseHexString(input.value.substr(2));
            }
            var res = computeCombine(shard_ids, shards);
            document.getElementById("combineoutput").innerHTML = byteArrayToHexString(res);
        } else if (type == 'bitlocker' || type == 'file') {
            var i = 0;
            while (true) {
                if (document.getElementById("blc_" + i + "_0") == null)
                    break;
                var keystr = '';
                for (var g = 0; g < 8; g++) {
                    keystr += document.getElementById("blc_" + i + "_" + g).value;
                }
                if (keystr.length == 0)
                    break;
                shard_ids[i] = getBitlockerShardId(keystr);
                shards[i] = parseBitlockerKey(keystr);
                i++;
            }
            var res = computeCombine(shard_ids, shards);
            if (type == 'file') {
                window.crypto.subtle.importKey("raw", res, { name: "AES-GCM" }, false, ["decrypt"]).then(function (key) {
                    return window.crypto.subtle.decrypt({ name: "AES-GCM", iv: new Uint8Array(window.fileData.slice(0, 16)) },
                    key, new Uint8Array(window.fileData.slice(16))).then(function (data) {
                        var url = URL.createObjectURL(new Blob([data], { type: "application/octet-stream" }));
                        var dlLink = document.createElement("a");
                        dlLink.href = url;
                        dlLink.download = window.combineFile.name.replace(".aes128gcm.shattr.enc", "");
                        dlLink.click();
                        URL.revokeObjectURL(url);
                    }, function (err) {
                        document.getElementById("combineoutput").innerHTML = "Can't decrypt file. Incorrect or not enough shards?";
                    });
                });
            } else {
                document.getElementById("combineoutput").innerHTML = byteArrayToBitlockerKey(res, 0);
            }
        }
    }

    function addOption(selector, value, text) {
        var option = document.createElement("option");
        option.value = value;
        option.appendChild(document.createTextNode(text));
        selector.appendChild(option);
    }

    function addCryptoOptions(selector) {
        
        addOption(selector, "rsa", "RSA signing key");
        addOption(selector, "dsa", "DSA signing key");
        addOption(selector, "ecdsa", "ECDSA signing key");
    }
    </script>
</head>
<body>
    <h1>Shattr. Distributing Trust.</h1>
    <div id="column">
    <header>
        <nav id="menu">
            <a href="#" class="menubutton" onclick="showPage('home')">Home</a>
            <a href="#" class="menubutton" onclick="showPage('shard')">Shattr</a>
            <a href="#" class="menubutton" onclick="showPage('combine')">Combine</a>
            <a href="#" class="menubutton" onclick="showPage('tech')">Technical Details</a>
        </nav>
    </header>
    <div id="content">
    <div id="home">
        <p>
        Shattr is a website where you can split your secrets into several shards
        such that if a certain number of them are combined, the secret can be
        recovered, but otherwise, no information about the secret can be obtained.
        (More information for crypto nerds can be found <a href="#"
        onclick="showPage('tech')">here</a>.)
        </p>
        <p>For example, you can Shattr your Bitlocker recovery key and distribute
        the shards to trusted third parties in several different countries. If you
        ever need your Bitlocker recovery key, you can use a secure ephemeral
        communications system (e.g. <a href="https://whispersystems.org/">Red Phone</a>) 
        to obtain the shards and recover your Bitlocker key. However, it would be 
        difficult even for a powerful adversary (such as a foreign government) to obtain 
        enough shards to recover your key.
        </p>
        <p>
        You can also use Shattr to encrypt and decrypt files without the key ever
        leaving your browser. You can even use it to generate digital signatures
        that require the cooperation of multiple people. (In fact, the DNS root zone
        is signed using a similar technique!)
        </p>
        <p>
        All of this is done right in your browser, with no data ever being transmitted
        over the network. To prevent anyone from tampering with Shattr, always use
        HTTPS! For extra assurance, compare the hash of this HTML file with a known good
        copy (e.g. the one distributed on the DEFCON 22 CD). This file will never change.
        </p>
        <p>
        For more information on how to use Shattr or how it works, check out
        <a href="https://shattr.it/talk.pdf">these slides</a> from the Shattr talk given
        at the DEFCON 22 Crypto and Privacy Village.
        </p>
        <p>
        Questions? Comments? Concerns? Send them to <a href="https://twitter.com/supersat/">
        @supersat</a>on Twitter or <a href="mailto:feedback@shattr.it">feedback@shattr.it</a>.
        </p>
    </div>
    <div id="shard" class="app">
        I want to Shattr a <select id="shardtype" onchange="shardTypeSelected()">
            <option selected="selected"></option>
            <option value="hex">Hexidecimal key</option>
            <option value="bitlocker">Bitlocker key</option>
        </select>
        <div id="shardinputs">
            <div id="shardhexinput" class="hidden keyinput">
                <input id="key" type="text" maxlength="128" placeholder="Hex key" class="hexkey" />
            </div>
            <div id="shardbitlockerinput" class="hidden keyinput">
                <input id="blkey1" class="blkey" type="text" maxlength="6" placeholder="000000" />-
                <input id="blkey2" class="blkey" type="text" maxlength="6" placeholder="000000" />-
                <input id="blkey3" class="blkey" type="text" maxlength="6" placeholder="000000" />-
                <input id="blkey4" class="blkey" type="text" maxlength="6" placeholder="000000" /><br />
                <input id="blkey5" class="blkey" type="text" maxlength="6" placeholder="000000" />-
                <input id="blkey6" class="blkey" type="text" maxlength="6" placeholder="000000" />-
                <input id="blkey7" class="blkey" type="text" maxlength="6" placeholder="000000" />-
                <input id="blkey8" class="blkey" type="text" maxlength="6" placeholder="000000" />
            </div>
            <div id="shardfileinput" class="hidden">
                Drag your file here!
            </div>
        </div>
        <div id="shardoptions" class="hidden">
        Total Shards:
        <select id="shards">
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
        </select> 
        Minimum Threshold:
        <select id="threshold">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
        </select><br />
        <input type="button" name="compute" value="Compute shards" class="button" onclick="shard()"/>
        </div>
        <div id="shardoutput" class="hidden">
        </div>
    </div>
    <div id="combine" class="app">
        I want to combine a <select id="combinetype" onchange="combineTypeSelected()">
            <option selected="selected"></option>
            <option value="hex">Hexidecimal key</option>
            <option value="bitlocker">Bitlocker key</option>
        </select><br />
        <div id="combineinput">            
        </div>
        <div id="combineoptions">
            <div id="combinefileinput" class="hidden">
                Drag your file here!
            </div>
            <input type="button" name="compute" value="Combine shards" class="button" onclick="combine()"/>
        </div>
        <output id="combineoutput"></output>
    </div>
    <div id="tech" class="hidden">
        <p>
        Shattr uses byte-wise Shamir secret sharing using Rinjdael's finite field
        (<b>GF</b>(2<sup>8</sup>) with reducing polynomial x<sup>8</sup> + x<sup>4</sup>
        + x<sup>3</sup> + x + 1). This means that partial shards can be used to
        recover a partial key. However, this also means we can support keys of
        arbitrary length, and using a small finite field makes the code much
        easier to write and audit (no big integer support needed!).
        </p>
        <p>
        File encryption is done with 128-bit AES using GCM mode, which is an authenticated
        block cipher mode, so no MAC is required to ensure integrity. 128 bits should be
        adequate for most purposes, and is compatible with Microsoft's Bitlocker key encoding
        scheme, which is a bit more user-friendly than long hex strings.
        </p>
        <p>
        There have been some <a href="http://www.matasano.com/articles/javascript-cryptography/">
        spirited arguments</a> against Javascript cryptography, but we believe
        Shattr is secure for most applications. Shattr is delivered as a single
        HTML file over HTTPS, so there's no opportunity for external content to
        change the behavior of Shattr. We have committed to never modifying 
        this file, so anyone interested can verify that the same code is always
        served. Shattr uses crypto primitives built in to modern browsers,
        including secure random number generation.
        </p>
        <p>
        If you are concerned about timing attacks or key material left in memory,
        you can run Shattr completely offline on a separate machine.
        </p>
    </div>
    </div>
    </div>
</body>
<script type="text/javascript">
    var filedrop = document.getElementById("shardfileinput");
    filedrop.addEventListener("dragenter", dragenter, false);
    filedrop.addEventListener("dragover", dragover, false);
    filedrop.addEventListener("drop", shardFileDrop, false);

    filedrop = document.getElementById("combinefileinput");
    filedrop.addEventListener("dragenter", dragenter, false);
    filedrop.addEventListener("dragover", dragover, false);
    filedrop.addEventListener("drop", combineFileDrop, false);

    // IE11 supports the WebCrypto API, but under a different name.
    if (window.crypto == null && window.msCrypto != null)
        window.crypto = window.msCrypto;

    if (window.crypto == null) {
        alert("Your browser does not support secure random number generation " +
              "or other WebCrypto APIs. Shattr.it requires WebCrypto support " +
              "to work.");
    }

    if (window.crypto.subtle != null) {
        addCryptoOptions(document.getElementById("shardtype"));
        addCryptoOptions(document.getElementById("combinetype"));
    } else {
        alert("Your browser does not support the full WebCrypto API. File " +
              "encryption and signing options are not available.");
    }
</script>
</html>
